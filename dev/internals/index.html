<!DOCTYPE html>
<html lang="en"><head><meta charset="UTF-8"/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><title>Internals · DomDecOT.jl</title><script async src="https://www.googletagmanager.com/gtag/js?id=UA-136089579-2"></script><script>  window.dataLayer = window.dataLayer || [];
  function gtag(){dataLayer.push(arguments);}
  gtag('js', new Date());
  gtag('config', 'UA-136089579-2', {'page_path': location.pathname + location.search + location.hash});
</script><script data-outdated-warner src="../assets/warner.js"></script><link rel="canonical" href="https://ismedina.github.io/DomDecOT.jl/internals/"/><link href="https://cdnjs.cloudflare.com/ajax/libs/lato-font/3.0.0/css/lato-font.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/juliamono/0.039/juliamono-regular.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.3/css/fontawesome.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.3/css/solid.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.3/css/brands.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/KaTeX/0.13.11/katex.min.css" rel="stylesheet" type="text/css"/><script>documenterBaseURL=".."</script><script src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.3.6/require.min.js" data-main="../assets/documenter.js"></script><script src="../siteinfo.js"></script><script src="../../versions.js"></script><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/documenter-dark.css" data-theme-name="documenter-dark" data-theme-primary-dark/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/documenter-light.css" data-theme-name="documenter-light" data-theme-primary/><script src="../assets/themeswap.js"></script><link href="../assets/favicon.ico" rel="icon" type="image/x-icon"/></head><body><div id="documenter"><nav class="docs-sidebar"><div class="docs-package-name"><span class="docs-autofit"><a href="../">DomDecOT.jl</a></span></div><form class="docs-search" action="../search/"><input class="docs-search-query" id="documenter-search-query" name="q" type="text" placeholder="Search docs"/></form><ul class="docs-menu"><li><a class="tocitem" href="../">Home</a></li><li><span class="tocitem">Manual</span><ul><li><a class="tocitem" href="../library/">Library</a></li><li class="is-active"><a class="tocitem" href>Internals</a></li></ul></li></ul><div class="docs-version-selector field has-addons"><div class="control"><span class="docs-label button is-static is-size-7">Version</span></div><div class="docs-selector control is-expanded"><div class="select is-fullwidth is-size-7"><select id="documenter-version-selector"></select></div></div></div></nav><div class="docs-main"><header class="docs-navbar"><nav class="breadcrumb"><ul class="is-hidden-mobile"><li><a class="is-disabled">Manual</a></li><li class="is-active"><a href>Internals</a></li></ul><ul class="is-hidden-tablet"><li class="is-active"><a href>Internals</a></li></ul></nav><div class="docs-right"><a class="docs-edit-link" href="github.com/ismedina/DomDecOT.jl.git" title="Edit on GitHub"><span class="docs-icon fab"></span><span class="docs-label is-hidden-touch">Edit on GitHub</span></a><a class="docs-settings-button fas fa-cog" id="documenter-settings-button" href="#" title="Settings"></a><a class="docs-sidebar-button fa fa-bars is-hidden-desktop" id="documenter-sidebar-button" href="#"></a></div></header><article class="content" id="documenter-page"><article class="docstring"><header><a class="docstring-binding" id="DomDecOT.AbstractPlan" href="#DomDecOT.AbstractPlan"><code>DomDecOT.AbstractPlan</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">AbstractPlan</code></pre><p>Super type of all implementations of OT plans.</p></div><a class="docs-sourcelink" target="_blank" href="github.com/ismedina/DomDecOT.jl.git">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="DomDecOT.DomDecPlan" href="#DomDecOT.DomDecPlan"><code>DomDecOT.DomDecPlan</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">DomDecPlan(mu::AbstractMeasure, nu::AbstractMeasure, gamma,
            cellsize::Int[, basic_cells::Vector, 
            composite_cells::Vector, partitions::Vector,
            alphas::Vector, betas::Vector, 
            epsilon::Float64, partk::Int)</code></pre><p>A DomDecPlan is a struct that keeps track of the status of the  domain decomposition algorithm in an effient manner. Its arguments are</p><ul><li><code>mu</code>: AbstractMeasure representing the X marginal</li><li><code>nu</code>: AbstractMeasure representing the Y marginal</li><li><code>gamma</code>: <code>gamma[i]</code> is a sparse vector representing the current marginal   of basic cell <code>i</code>. Alternatively, <code>gamma</code> can also be a sparse matrix   representing the full initial plan.</li><li><code>cellsize::Int</code>: maximum size of the basic cells (along all dimensions).</li><li><code>basic_cells</code>: <code>basic_cells[i]</code> is the indices of the atoms in <code>mu</code> that   are merged together to form a basic cell. </li><li><code>composite_cells</code>: <code>composite_cells[k][j]</code> refers to the group of basic cells   that constitute the <code>j</code>-th subdomain of the <code>k</code>-th partition.</li><li><code>partitions</code>: <code>partitions[k][j]</code> are the indices of all the <code>X</code> atoms that constitute the    first marginal during <code>j</code>-th subdomain of partition <code>k</code>. It equals    <code>vcat([basic_cells[composite_cells[k][j]]...)</code></li><li><code>alphas</code>: X-dual potential on each subdomain. <code>alphas[k][j]</code> has the same length as <code>partitions[k][j]</code>.</li><li><code>betas</code>: Y-dual potentials on each subdomain.</li><li><code>epsilon</code>: last global epsilon used to solve the cell problems.</li><li><code>partk</code>: index of the last partition whose subdomains were solved.</li></ul></div><a class="docs-sourcelink" target="_blank" href="github.com/ismedina/DomDecOT.jl.git">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="DomDecOT.PD_gap-Tuple{Any, Any, Any}" href="#DomDecOT.PD_gap-Tuple{Any, Any, Any}"><code>DomDecOT.PD_gap</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">PD_gap(P, c,  ε)</code></pre><p>Primal-dual gap of plan <code>P</code> for the cost <code>c</code> and regularization <code>ε</code>.</p></div><a class="docs-sourcelink" target="_blank" href="github.com/ismedina/DomDecOT.jl.git">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="DomDecOT.balance!" href="#DomDecOT.balance!"><code>DomDecOT.balance!</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">balance!(Q, μ, threshold, force_balancing = true)</code></pre><p>Apply <code>balance!</code> with threshold <code>threshold</code> on pairs of columns of <code>Q</code>  until each column <code>Q[:,i]</code> has mass μ. When <code>force_balancing == true</code>, if a first pass wasn&#39;t succesful,  a second pass is attempted seeting <code>threshold = 0</code>.</p></div><a class="docs-sourcelink" target="_blank" href="github.com/ismedina/DomDecOT.jl.git">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="DomDecOT.balance!-NTuple{4, Any}" href="#DomDecOT.balance!-NTuple{4, Any}"><code>DomDecOT.balance!</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">balance!(a, b, δ, threshold; force_balancing = false)</code></pre><p>Transfer <code>δ</code> mass from vector <code>a</code> to <code>b</code>. The recipient entries must be larger than <code>threshold</code>; if it is not achieved a warning is thrown.</p></div><a class="docs-sourcelink" target="_blank" href="github.com/ismedina/DomDecOT.jl.git">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="DomDecOT.cell_PD_gap-NTuple{5, Any}" href="#DomDecOT.cell_PD_gap-NTuple{5, Any}"><code>DomDecOT.cell_PD_gap</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">cell_PD_gap(P, k, j, c, ε)</code></pre><p>Primal-dual gap in cell j of partition k.</p></div><a class="docs-sourcelink" target="_blank" href="github.com/ismedina/DomDecOT.jl.git">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="DomDecOT.domdec_logsinkhorn!-NTuple{7, Any}" href="#DomDecOT.domdec_logsinkhorn!-NTuple{7, Any}"><code>DomDecOT.domdec_logsinkhorn!</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">domdec_logsinkhorn!(β, α, νJ, νI, μJ, C, ε; kwargs...)</code></pre><p>Solve cell problem using the log-domain Sinkhorn algorithm of the  <code>MultiScaleOT</code> library. </p><p><strong>Arguments</strong></p><ul><li>β: initial Y dual potential</li><li>α: initial X dual potential</li><li>νJ: Y cell marginal </li><li>νI: global Y marginal supported on the same points as νJ_global</li><li>μJ: X cell marginal</li><li>C: cost matrix. It is transformed inplace to yield the primal plan </li><li>ε: regularization</li></ul></div><a class="docs-sourcelink" target="_blank" href="github.com/ismedina/DomDecOT.jl.git">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="DomDecOT.domdec_sinkhorn_autofix_log!-NTuple{7, Any}" href="#DomDecOT.domdec_sinkhorn_autofix_log!-NTuple{7, Any}"><code>DomDecOT.domdec_sinkhorn_autofix_log!</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">domdec_sinkhorn_autofix_log!(β, α, νJ, νI, μJ, C, ε; kwargs...)</code></pre><p>Attempt to solve the cell problem by calling sinkhorn_stabilized!. If the algorithm errors, fall back to logsinkhorn!. </p><p><strong>Arguments</strong></p><ul><li>β: initial Y dual potential</li><li>α: initial X dual potential</li><li>νJ: Y cell marginal </li><li>νI: global Y marginal supported on the same points as νJ_global</li><li>μJ: X cell marginal</li><li>C: cost matrix. It is transformed inplace to yield the primal plan </li><li>ε: regularization</li></ul></div><a class="docs-sourcelink" target="_blank" href="github.com/ismedina/DomDecOT.jl.git">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="DomDecOT.domdec_sinkhorn_stabilized!-NTuple{7, Any}" href="#DomDecOT.domdec_sinkhorn_stabilized!-NTuple{7, Any}"><code>DomDecOT.domdec_sinkhorn_stabilized!</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">domdec_sinkhorn_stabilized!(β, α, νJ, νI, μJ, C, ε; kwargs...)</code></pre><p>Solve cell problem using the stabilized Sinkhorn algorithm of the  <code>MultiScaleOT</code> library. </p><p><strong>Arguments</strong></p><ul><li>β: initial Y dual potential</li><li>α: initial X dual potential</li><li>νJ: Y cell marginal </li><li>νI: global Y marginal supported on the same points as νJ_global</li><li>μJ: X cell marginal</li><li>C: cost matrix. It is transformed inplace to yield the primal plan </li><li>ε: regularization</li></ul></div><a class="docs-sourcelink" target="_blank" href="github.com/ismedina/DomDecOT.jl.git">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="DomDecOT.dual_score-Tuple{Any, Any, Any}" href="#DomDecOT.dual_score-Tuple{Any, Any, Any}"><code>DomDecOT.dual_score</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">dual_score(P, c,  ε)</code></pre><p>Compute the dual score of <code>P</code> for the entropic problem  with cost function <code>c</code> and regularization <code>ε</code>, using only the non-zero entries of <code>P</code>. For the dense dual score, consider converting first <code>P</code> to a sparse matrix and then using the routines of MultiScaleOT.</p></div><a class="docs-sourcelink" target="_blank" href="github.com/ismedina/DomDecOT.jl.git">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="DomDecOT.fix_beta!-NTuple{7, Any}" href="#DomDecOT.fix_beta!-NTuple{7, Any}"><code>DomDecOT.fix_beta!</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">fix_beta!(β, α, C, νJ, νI, μJ, ε)</code></pre><p>Set β to the conjugate of α, taking into account the cell parameters. Stable implementation.</p></div><a class="docs-sourcelink" target="_blank" href="github.com/ismedina/DomDecOT.jl.git">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="DomDecOT.fix_beta!-Tuple{Any, Int64}" href="#DomDecOT.fix_beta!-Tuple{Any, Int64}"><code>DomDecOT.fix_beta!</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">fix_beta!(β, N::Int)</code></pre><p>Check if the Y-dual parameter has the appropriate size. If not, turns it  into a zeros(N).  Return <code>true</code> if β was of the appropriate length, <code>false</code> otherwise</p></div><a class="docs-sourcelink" target="_blank" href="github.com/ismedina/DomDecOT.jl.git">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="DomDecOT.get_alpha_field-Union{Tuple{M}, Tuple{D}, Tuple{DomDecPlan{MultiScaleOT.GridMeasure{D}, M}, Any}} where {D, M}" href="#DomDecOT.get_alpha_field-Union{Tuple{M}, Tuple{D}, Tuple{DomDecPlan{MultiScaleOT.GridMeasure{D}, M}, Any}} where {D, M}"><code>DomDecOT.get_alpha_field</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">get_alpha_field(P, k)</code></pre><p>Glue cell duals of partition <code>k</code> to form a global dual.</p></div><a class="docs-sourcelink" target="_blank" href="github.com/ismedina/DomDecOT.jl.git">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="DomDecOT.get_alpha_graph-Union{Tuple{M}, Tuple{DomDecPlan{MultiScaleOT.GridMeasure{1}, M}, Any}} where M" href="#DomDecOT.get_alpha_graph-Union{Tuple{M}, Tuple{DomDecPlan{MultiScaleOT.GridMeasure{1}, M}, Any}} where M"><code>DomDecOT.get_alpha_graph</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">get_alpha_graph(P::DomDecPlan, alpha_diff, cellsize)</code></pre><p>Compute Helmholtz decomposition on, <code>alpha_diff</code>, averaging on basic cells, as explained in https://arxiv.org/abs/2001.10986, Section 6.3.</p></div><a class="docs-sourcelink" target="_blank" href="github.com/ismedina/DomDecOT.jl.git">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="DomDecOT.get_basic_and_composite_cells-Tuple{Any, Any}" href="#DomDecOT.get_basic_and_composite_cells-Tuple{Any, Any}"><code>DomDecOT.get_basic_and_composite_cells</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">get_basic_and_composite_cells(gridshape, cellsize)</code></pre><p>Get the basic and composite cells corresponding to partitioning a grid of shape <code>gridshape</code> into basic cells of size  at most <code>cellsize × ... × cellsize</code>, and then joining groups of 2^D adjacent basic cells together to form composite cells <code>compA</code>. <code>compB</code> is obtained in an analogous manner, but with an offset of  1 along each axes.</p><p><strong>Examples</strong></p></div><a class="docs-sourcelink" target="_blank" href="github.com/ismedina/DomDecOT.jl.git">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="DomDecOT.get_cell_Y_marginal-Tuple{DomDecPlan, Any}" href="#DomDecOT.get_cell_Y_marginal-Tuple{DomDecPlan, Any}"><code>DomDecOT.get_cell_Y_marginal</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">get_cell_Y_marginal(P, J)</code></pre><p>Compute the total Y-marginal of a set of <strong>basic cells</strong> <code>J</code></p></div><a class="docs-sourcelink" target="_blank" href="github.com/ismedina/DomDecOT.jl.git">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="DomDecOT.get_cost_matrix-NTuple{4, Any}" href="#DomDecOT.get_cost_matrix-NTuple{4, Any}"><code>DomDecOT.get_cost_matrix</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">get_cost_matrix(P, c, J, I)</code></pre><p>Return the cost matrix corresponding to points Y[:,I] and X[:,J].</p></div><a class="docs-sourcelink" target="_blank" href="github.com/ismedina/DomDecOT.jl.git">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="DomDecOT.get_discrete_gradient-Tuple{Any, Any, Any}" href="#DomDecOT.get_discrete_gradient-Tuple{Any, Any, Any}"><code>DomDecOT.get_discrete_gradient</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">get_discrete_gradient(nx, ny, nz)</code></pre><p>Get (transpose of) X-, Y- and Z-gradient matrices for a discrete graph of size <code>(nx, ny, nz)</code>.</p></div><a class="docs-sourcelink" target="_blank" href="github.com/ismedina/DomDecOT.jl.git">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="DomDecOT.get_discrete_gradient-Tuple{Any, Any}" href="#DomDecOT.get_discrete_gradient-Tuple{Any, Any}"><code>DomDecOT.get_discrete_gradient</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">get_discrete_gradient(nx, ny)</code></pre><p>Get (transpose of) X- and Y-gradient matrices for a discrete graph of size <code>(nx, ny)</code>.</p><p><strong>Relation with the Python library</strong></p><p>If we define in Julia</p><pre><code class="language-julia hljs">gx, gy = get_discrete_gradient(nx, ny)</code></pre><p>and in Python</p><pre><code class="language-python hljs">GX, GY = Common.getDiscreteGradients(ny, nx)</code></pre><p>Then <code>GX, GY == gx&#39;, gy&#39;</code></p></div><a class="docs-sourcelink" target="_blank" href="github.com/ismedina/DomDecOT.jl.git">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="DomDecOT.get_discrete_gradient-Tuple{Any}" href="#DomDecOT.get_discrete_gradient-Tuple{Any}"><code>DomDecOT.get_discrete_gradient</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">get_discrete_gradient(nx)</code></pre><p>Get (transpose of) X-gradient matrices for a one dimensional lattice of size <code>nx</code>.</p></div><a class="docs-sourcelink" target="_blank" href="github.com/ismedina/DomDecOT.jl.git">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="DomDecOT.get_pairwise_delta-Tuple{Any, Any}" href="#DomDecOT.get_pairwise_delta-Tuple{Any, Any}"><code>DomDecOT.get_pairwise_delta</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">get_pairwise_delta(d1, d2)</code></pre><p>For a pair of values <code>d1, d2</code> representing the offset of mass of two vectors,  computes the maximum possible transfer of mass that does not make any vector worse than what it is currently. For example, if both vectors have mass in excess or in defect, it returns 0; if one has in excess and another in defect, it returns the smallest of these adjustments, with the corresponding sign. </p><p><strong>Examples</strong></p><p>julia&gt; get<em>pairwise</em>delta(1,2), get<em>pairwise</em>delta(-1, -3) (0, 0)</p><p>julia&gt; get<em>pairwise</em>delta(1,-2) 1</p><p>julia&gt; get<em>pairwise</em>delta(-1,2) -1</p></div><a class="docs-sourcelink" target="_blank" href="github.com/ismedina/DomDecOT.jl.git">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="DomDecOT.get_partition-Tuple{Any, Any}" href="#DomDecOT.get_partition-Tuple{Any, Any}"><code>DomDecOT.get_partition</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">get_partition(basic_cells, composite_cells)</code></pre><p>Compute a partition by joining the basic cells corresponding to each composite cells. </p><p><strong>Examples</strong></p><pre><code class="language-julia-repl hljs">julia&gt; DD.get_partition([[1], [2, 3], [4]], [[1, 2], [3]])
2-element Vector{Vector{Int64}}:
 [1, 2, 3]
 [4]</code></pre></div><a class="docs-sourcelink" target="_blank" href="github.com/ismedina/DomDecOT.jl.git">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="DomDecOT.iterate!-Tuple{DomDecPlan, Any, Any, NamedTuple}" href="#DomDecOT.iterate!-Tuple{DomDecPlan, Any, Any, NamedTuple}"><code>DomDecOT.iterate!</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">iterate!(P, c, solver, params::NamedTuple)</code></pre><p>Perform <code>params[:iters]</code> inplace iterations of the domain decomposition algorithm  on the plan <code>P</code>, using the cost <code>c</code> and the inner solver <code>solver</code>.  If <code>params[:parallel_iteration]</code> is true, runs the iterations in parallel.</p></div><a class="docs-sourcelink" target="_blank" href="github.com/ismedina/DomDecOT.jl.git">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="DomDecOT.iterate_parallel!-Tuple{Any, Int64, Any, Any, Any}" href="#DomDecOT.iterate_parallel!-Tuple{Any, Int64, Any, Any, Any}"><code>DomDecOT.iterate_parallel!</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">iterate_parallel!(P, k, c, solver, params)</code></pre><p>Run an (inplace), parallel half iteration <code>k</code> of domain decomposition  on plan <code>P</code>, with cost <code>c</code>, solver <code>solver</code> and ceratain <code>params</code>.</p></div><a class="docs-sourcelink" target="_blank" href="github.com/ismedina/DomDecOT.jl.git">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="DomDecOT.iterate_serial!-Tuple{Any, Int64, Any, Any, Any}" href="#DomDecOT.iterate_serial!-Tuple{Any, Int64, Any, Any, Any}"><code>DomDecOT.iterate_serial!</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">iterate_serial!(P, k, c, solver, params)</code></pre><p>Run an (inplace), serial half iteration <code>k</code> of domain decomposition  on plan <code>P</code>, with cost <code>c</code>, solver <code>solver</code> and ceratain <code>params</code>.</p></div><a class="docs-sourcelink" target="_blank" href="github.com/ismedina/DomDecOT.jl.git">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="DomDecOT.plan_to_dense_matrix" href="#DomDecOT.plan_to_dense_matrix"><code>DomDecOT.plan_to_dense_matrix</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">plan_to_dense_matrix(P, c[, k, balancing = true])</code></pre><p>Turn P into a dense matrix using the dual potentials of partition <code>k</code>.</p></div><a class="docs-sourcelink" target="_blank" href="github.com/ismedina/DomDecOT.jl.git">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="DomDecOT.plan_to_sparse_matrix" href="#DomDecOT.plan_to_sparse_matrix"><code>DomDecOT.plan_to_sparse_matrix</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">plan_to_sparse_matrix(P, c[, k, balancing = true])</code></pre><p>Turn P into a sparse matrix using the dual in the last iteration.</p></div><a class="docs-sourcelink" target="_blank" href="github.com/ismedina/DomDecOT.jl.git">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="DomDecOT.primal_score-Tuple{Any, Any, Any}" href="#DomDecOT.primal_score-Tuple{Any, Any, Any}"><code>DomDecOT.primal_score</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">primal_score(P, c, ε)</code></pre><p>Compute the primal score of <code>P</code> for the entropic problem  with cost function <code>c</code> and regularization <code>ε</code>, using only the non-zero entries of <code>P</code>. </p></div><a class="docs-sourcelink" target="_blank" href="github.com/ismedina/DomDecOT.jl.git">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="DomDecOT.reduce_cellplan_to_cellmarginals-Tuple{DomDecPlan, AbstractMatrix{T} where T, Any, Any, Any}" href="#DomDecOT.reduce_cellplan_to_cellmarginals-Tuple{DomDecPlan, AbstractMatrix{T} where T, Any, Any, Any}"><code>DomDecOT.reduce_cellplan_to_cellmarginals</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">reduce_cellplan_to_cellmarginals(P::DomDecPlan, PJ::AbstractMatrix, k, j, μJ)</code></pre><p>Take the matrix <code>PJ</code>, that is assumed to be the current plan on cell <code>k</code> of partition <code>k</code> and extract its cell marginals.</p></div><a class="docs-sourcelink" target="_blank" href="github.com/ismedina/DomDecOT.jl.git">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="DomDecOT.reduce_to_cells-Tuple{AbstractMatrix{T} where T, Any}" href="#DomDecOT.reduce_to_cells-Tuple{AbstractMatrix{T} where T, Any}"><code>DomDecOT.reduce_to_cells</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">reduce_to_cellsize(γ0::AbstractMatrix, basic_cells)</code></pre><p>Add together marginals corresponding to the same basic cell.</p></div><a class="docs-sourcelink" target="_blank" href="github.com/ismedina/DomDecOT.jl.git">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="DomDecOT.reduce_to_cells-Tuple{AbstractVector{AbstractVector{T} where T}, Any}" href="#DomDecOT.reduce_to_cells-Tuple{AbstractVector{AbstractVector{T} where T}, Any}"><code>DomDecOT.reduce_to_cells</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">reduce_to_cellsize(γ0::AbstractVector, basic_cells)</code></pre><p>Add together marginals corresponding to the same basic cell.</p></div><a class="docs-sourcelink" target="_blank" href="github.com/ismedina/DomDecOT.jl.git">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="DomDecOT.reduce_to_cells-Tuple{Any, Any, Any}" href="#DomDecOT.reduce_to_cells-Tuple{Any, Any, Any}"><code>DomDecOT.reduce_to_cells</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">reduce_to_cells(gamma, gridshape, cellSize)</code></pre><p>Add together marginals corresponding to the same basic cell,  for given <code>shapeX</code> and <code>cellSize</code>.</p></div><a class="docs-sourcelink" target="_blank" href="github.com/ismedina/DomDecOT.jl.git">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="DomDecOT.refine_plan-Union{Tuple{D}, Tuple{DomDecPlan, MultiScaleOT.MultiScaleMeasure{MultiScaleOT.GridMeasure{D}}, MultiScaleOT.MultiScaleMeasure, Int64}} where D" href="#DomDecOT.refine_plan-Union{Tuple{D}, Tuple{DomDecPlan, MultiScaleOT.MultiScaleMeasure{MultiScaleOT.GridMeasure{D}}, MultiScaleOT.MultiScaleMeasure, Int64}} where D"><code>DomDecOT.refine_plan</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">refine_plan(P::DomDecPlan, 
            μH::MultiScaleMeasure{GridMeasure{D}}, 
            νH::MultiScaleMeasure, 
            k::Int;
            consistency_check = true) where D</code></pre><p>Refine the plan P to match the refinement of the X marginal  μH[k-1] -&gt; μH[k] and of the Y marginal νH[k-1] -&gt; νH[k]</p></div><a class="docs-sourcelink" target="_blank" href="github.com/ismedina/DomDecOT.jl.git">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="DomDecOT.refine_submeasure-Tuple{SparseArrays.SparseVector, Any, Any, Any}" href="#DomDecOT.refine_submeasure-Tuple{SparseArrays.SparseVector, Any, Any, Any}"><code>DomDecOT.refine_submeasure</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">refine_submeasure(v, u, u2, Js)</code></pre><p>Refine the measure <code>v</code> with respect to the Y-cells given in <code>Js</code> by matching the pattern induced by the refinement u -&gt; u2.</p></div><a class="docs-sourcelink" target="_blank" href="github.com/ismedina/DomDecOT.jl.git">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="DomDecOT.smooth_alpha_and_beta_fields-Union{Tuple{M}, Tuple{D}, Tuple{DomDecPlan{MultiScaleOT.GridMeasure{D}, M}, Any}} where {D, M}" href="#DomDecOT.smooth_alpha_and_beta_fields-Union{Tuple{M}, Tuple{D}, Tuple{DomDecPlan{MultiScaleOT.GridMeasure{D}, M}, Any}} where {D, M}"><code>DomDecOT.smooth_alpha_and_beta_fields</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">smooth_alpha_and_beta_field(P::DomDecPlan, c)</code></pre><p>Compute a smooth version of the duals of <code>P</code> by performing a Helmholtz decomposition (see https://arxiv.org/abs/2001.10986, Section 6.3 for details)</p></div><a class="docs-sourcelink" target="_blank" href="github.com/ismedina/DomDecOT.jl.git">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="DomDecOT.smooth_alpha_field-Union{Tuple{DomDecPlan{MultiScaleOT.GridMeasure{D}, M}}, Tuple{M}, Tuple{D}} where {D, M}" href="#DomDecOT.smooth_alpha_field-Union{Tuple{DomDecPlan{MultiScaleOT.GridMeasure{D}, M}}, Tuple{M}, Tuple{D}} where {D, M}"><code>DomDecOT.smooth_alpha_field</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">smooth_alpha_field(P::DomDecPlan, cellsize)</code></pre><p>Compute a smooth version of the <code>X</code> dual of <code>P</code> by performing a Helmholtz decomposition  (see https://arxiv.org/abs/2001.10986, Section 6.3 for details)</p></div><a class="docs-sourcelink" target="_blank" href="github.com/ismedina/DomDecOT.jl.git">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="DomDecOT.solvecell!-Tuple{DomDecPlan, Any, Any, Any, Any, Any}" href="#DomDecOT.solvecell!-Tuple{DomDecPlan, Any, Any, Any, Any, Any}"><code>DomDecOT.solvecell!</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">solvecell!(P::DomDecPlan, k, j, c, solver, params)</code></pre><p>Perform an (inplace) cell iteration on cell <code>P.partitions[k][j]</code> of the plan <code>P</code>, using the inner <code>solver</code> and the given <code>params</code>.</p></div><a class="docs-sourcelink" target="_blank" href="github.com/ismedina/DomDecOT.jl.git">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="DomDecOT.truncate!-Tuple{AbstractArray, Any}" href="#DomDecOT.truncate!-Tuple{AbstractArray, Any}"><code>DomDecOT.truncate!</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">truncate!(A, [μJ, ] threshold)</code></pre><p>Drop values of <code>ν</code> smaller or equal than <code>threshold</code>. Acts inplace. If μJ is given and A is a matrix, call</p><pre><code class="language-julia hljs">truncate!(A[:,i], μJ[i]*threshold)</code></pre><p>for each column of A.</p></div><a class="docs-sourcelink" target="_blank" href="github.com/ismedina/DomDecOT.jl.git">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="DomDecOT.truncate!-Tuple{DomDecPlan, Any}" href="#DomDecOT.truncate!-Tuple{DomDecPlan, Any}"><code>DomDecOT.truncate!</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">truncate!(P::AbstractPlan, rel_threshold)</code></pre><p>Drop values of the plan <code>P</code> that are smaller than <code>rel_threshold</code> with respect to the cell mass. Acts inplace.</p></div><a class="docs-sourcelink" target="_blank" href="github.com/ismedina/DomDecOT.jl.git">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="DomDecOT.update_cell_plan!-Tuple{DomDecPlan, Any, Any, Any, Any, Any}" href="#DomDecOT.update_cell_plan!-Tuple{DomDecPlan, Any, Any, Any, Any, Any}"><code>DomDecOT.update_cell_plan!</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">update_cell_plan!(P::DomDecPlan, PJ, I, k, j, μJ[;
        balance = true, truncate = true,
        truncate_Ythresh = 1e-16, truncate_Ythresh_rel=true])</code></pre><p>Update cell <code>j</code> of partition <code>k</code> with the given cell plan <code>PJ</code>.</p></div><a class="docs-sourcelink" target="_blank" href="github.com/ismedina/DomDecOT.jl.git">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="DomDecOT.update_cell_plan!-Tuple{DomDecPlan, Any, Any, Any, Any}" href="#DomDecOT.update_cell_plan!-Tuple{DomDecPlan, Any, Any, Any, Any}"><code>DomDecOT.update_cell_plan!</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">update_cell_plan!(P::DomDecPlan, P_basic, k, j, I)</code></pre><p>Update cell <code>j</code> of partition <code>k</code> of the plan <code>P</code> using the columns in <code>P_basic</code> as the basic cell marginals. <code>I</code> is the real support of the columns of P_basic</p></div><a class="docs-sourcelink" target="_blank" href="github.com/ismedina/DomDecOT.jl.git">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="DomDecOT.view_X-Tuple{Any, Any}" href="#DomDecOT.view_X-Tuple{Any, Any}"><code>DomDecOT.view_X</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">view_X(P, J)</code></pre><p>Return a view of the X points in subset <code>J</code> of <code>P.mu.points</code>.</p></div><a class="docs-sourcelink" target="_blank" href="github.com/ismedina/DomDecOT.jl.git">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="DomDecOT.view_Y-Tuple{Any, Any}" href="#DomDecOT.view_Y-Tuple{Any, Any}"><code>DomDecOT.view_Y</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">view_cell_Y(P, I)</code></pre><p>Return a view of the Y points with index <code>I</code>.</p></div><a class="docs-sourcelink" target="_blank" href="github.com/ismedina/DomDecOT.jl.git">source</a></section></article></article><nav class="docs-footer"><a class="docs-footer-prevpage" href="../library/">« Library</a><div class="flexbox-break"></div><p class="footer-message">Powered by <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> and the <a href="https://julialang.org/">Julia Programming Language</a>.</p></nav></div><div class="modal" id="documenter-settings"><div class="modal-background"></div><div class="modal-card"><header class="modal-card-head"><p class="modal-card-title">Settings</p><button class="delete"></button></header><section class="modal-card-body"><p><label class="label">Theme</label><div class="select"><select id="documenter-themepicker"><option value="documenter-light">documenter-light</option><option value="documenter-dark">documenter-dark</option></select></div></p><hr/><p>This document was generated with <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> version 0.27.10 on <span class="colophon-date" title="Sunday 21 November 2021 20:35">Sunday 21 November 2021</span>. Using Julia version 1.6.4.</p></section><footer class="modal-card-foot"></footer></div></div></div></body></html>
